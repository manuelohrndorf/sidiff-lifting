Index: META-INF/MANIFEST.MF
===================================================================
--- META-INF/MANIFEST.MF	(revision 285)
+++ META-INF/MANIFEST.MF	(revision 563)
@@ -9,7 +9,8 @@
 Bundle-ActivationPolicy: lazy
 Require-Bundle: org.eclipse.emf.ecore.xmi;bundle-version="2.5.0",
  org.eclipse.emf.ecore.change;bundle-version="2.5.0";visibility:=reexport,
- org.eclipse.emf.henshin.model;bundle-version="0.9.0";visibility:=reexport
+ org.eclipse.emf.henshin.model;bundle-version="0.9.0";visibility:=reexport,
+ org.sidiff.difference.util;bundle-version="1.0.0"
 Export-Package: org.eclipse.emf.henshin.interpreter,
  org.eclipse.emf.henshin.interpreter.impl,
  org.eclipse.emf.henshin.interpreter.info,
Index: src/org/eclipse/emf/henshin/interpreter/matching/constraints/DanglingConstraint.java
===================================================================
--- src/org/eclipse/emf/henshin/interpreter/matching/constraints/DanglingConstraint.java	(revision 285)
+++ src/org/eclipse/emf/henshin/interpreter/matching/constraints/DanglingConstraint.java	(revision 563)
@@ -11,13 +11,16 @@
 
 import java.util.Collection;
 import java.util.HashMap;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 
 import org.eclipse.emf.ecore.EObject;
 import org.eclipse.emf.ecore.EReference;
 import org.eclipse.emf.ecore.EStructuralFeature.Setting;
+import org.eclipse.emf.ecore.EcorePackage;
 import org.eclipse.emf.henshin.interpreter.EGraph;
+import org.sidiff.difference.util.access.EMFMetaAccessEx;
 
 /**
  * This constraint checks whether the value of an EReference contains objects
@@ -53,6 +56,23 @@
 		
 		// Compute the actual number of incoming edges:
 		Collection<Setting> settings = graph.getCrossReferenceAdapter().getInverseReferences(sourceValue);
+		
+		// ===== FIXME: Begin Workaround ============================
+		// (1) falsche gecachte Werte fÃ¼r eingehende Referenzen => ignoriere Generics
+		// (2) nicht beachten: derived, unchangeable und transient references.
+		for (Iterator<Setting> iterator = settings.iterator(); iterator.hasNext();) {
+			Setting setting = iterator.next();
+			if (setting.getEStructuralFeature().equals(EcorePackage.eINSTANCE.getEGenericType_EClassifier())   		||
+				setting.getEStructuralFeature().equals(EcorePackage.eINSTANCE.getEGenericType_ERawType())  			||
+				setting.getEStructuralFeature().equals(EcorePackage.eINSTANCE.getEGenericType_ETypeParameter())     ||
+				EMFMetaAccessEx.isUnconsideredStructualFeature(setting.getEStructuralFeature())
+			   ) 
+			{
+				iterator.remove();
+			}	
+		}
+		// ===== FIXME: End Workaround ==============================
+		
 		Map<EReference, Integer> actualIncomingEdges = createMapFromSettings(settings);
 		Integer expectedCount;
 
